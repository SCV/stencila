import { DefaultDOMElement } from 'substance'

import HostInstance from '../host/HostInstance'

export default class DocumentDocxConverter {

  static match (fileName) {
    return fileName.slice(-5) === '.docx'
  }

  importDocument(storer, buffer) {
    let mainFilePath = storer.getMainFilePath()
    let manifest = {
      "type": "document",
      "storage": {
        "external": storer.isExternal(),
        "storerType": storer.getType(),
        "archivePath": storer.getArchivePath(),
        "mainFilePath": mainFilePath,
        "contentType": "md",
      },
      "createdAt": new Date(),
      "updatedAt": new Date()
    }
    return storer.readFile(
      mainFilePath,
      'text/html'
    ).then(md => {
      let html = `<!DOCTYPE html>
<html>
  <head>
    <title></title>
  </head>
  <body>
    <main>
      <div id="data" data-format="html">
        <div class="content">${this.importContent(md)}</div>
      </div>
    </main>
  </body>
</html>`
      return buffer.writeFile(
        'index.html',
        'text/html',
        html
      )
    }).then(() => {
      return buffer.writeFile(
        'stencila-manifest.json',
        'application/json',
        JSON.stringify(manifest, null, '  ')
      )
    }).then(() => {
      return manifest
    })
  }

  exportDocument(buffer, storer, options = {}) {
    if (!options.converter) options.converter = 'pandoc'

    return buffer.readFile('index.html', 'text/html').then((html) => {
      let shtml = DefaultDOMElement.parseHTML(html).find('.content').getInnerHTML()
      let phtml = this.exportContent(shtml)

      let convert
      if (options.converter === 'pandoc') {
        convert = HostInstance.post('Pandoc').then(pandoc => {
          // This assumes that the filesystem converter is being used so that we
          // can get pandoc to output directly to a file. But the alternative is to 
          // get pandoc to return bytes, so that they can be written to any storer
          let filePath = storer.getArchivePath() + '/' + storer.getMainFilePath()
          return pandoc.call('convert', phtml, 'html', 'docx', { output: filePath })
        })
      } else {
        // This is only here for being able to test this independently of running
        // a peer which provides Pandoc
        convert = Promise.resolve(`DocumentDocxConverter.exportDocument was run with converter: ${options.converter}`)
      }

      return convert.then(() => {
        // Nothing is being done here. But if, instead of passing the `output` option to pandoc
        // above, we got the docx content back, we would get the storer to write it here.
        return true
      })
    })
  }

  /**
   * Import a document from Pandoc HTML (generated by
   * converting a docx to HTML) to Stencila HTML
   * 
   * @param  {string} phtml   Pandoc HTML
   * @param  {Object} options Conversion options
   * @return {string}         Stencila HTML
   */
  importContent (phtml, options = {}) {
    // Convert `<div class="footnotes"><ol>` items to 
    return html
  }

  /**
   * Export a document from Stencila HTML to Pandoc HTML
   * so that we can use Pandoc to convert to docx
   * 
   * @param  {string} html    Stencila HTML
   * @param  {Object} options Conversion options
   * @return {string}         Pandoc HTML
   */
  exportContent (html, options = {}) {
    let phtml = "Some content"

    return phtml
  }
}
